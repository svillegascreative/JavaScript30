# \# 12 - Key Sequence Detection


## Exercise
Detect if a user has pressed a particular sequence of keys. This could be used, for example, to detect if a user has keyed a secret code that enables hidden interactions (ie. "Easter eggs").

## Impressions
- I had a **very** hard time initially figuring out why Wes chose `splice()` over `slice()` to get the last *x* keys pressed by the user (to compare them to a secret code of length *x*). I realized, explaining it to myself out loud, that the latter returns a *shallow copy of the provided array*, leaving the original array untouched. So, while `slice()` may provide me just the *x* keys I wanted in the return in a new array, the original array would *keep getting longer*. `splice()`, on the other hand, would somehow take prevent that growth, with deletion taking place within the original array, and could maintain the array at a desired length.
- The next question was 'how?'. But, no, really: **__How!??!?__**. I think that because I have a highly visual mind, I had a very particular mental representation of how `splice()` works, and I couldn't fit Wes' implementation into that model. It took a **lot** of (re)reading the [MDN spec](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice) and stepwise console logging various expressions to finally make it click. Two things I figured out, which had to do with the `pressed.length - secretCode.length` expression being used as the `deleteCount` argument:
  1. The spec doesn't explain what happens if the `deleteCount` argument is a *negative* number. Turns out it's the same as if it's `0`: nothing is deleted from the array. This is what happens for your first *x* keystrokes, when the length of your secret code is longer than the array of pressed keys and the expression evaluates negative.
  2. Beyond that, when the user has pressed more than *x* keys, *only ever evaluates to 1*. Yeah. Ye-ahhhhhhh. As soon as you `push()` a key into the array, it is 1 item longer than the secret code; then, you `splice()` that difference (the 1 item at the start of the array), returning both arrays to the same length. At the next keypress, the same thing happens (`push()` one, `splice()` all but one), so your pressed keys array always stays the same length. Wow. That blew my mind.
- I initially tried comparing (with `==` only, not `===`) the keypress array with the secret code in array form (using `Array.from()`) and it failed. Conversely, comparing the array as a string (with `join("")`) was successful. I'm still not sure why that is.
